#!/usr/bin/env node

import pg from 'pg';

const { Client } = pg;

function requireEnv(name) {
  const value = process.env[name];
  if (!value || !String(value).trim()) {
    throw new Error(`Missing required env: ${name}`);
  }
  return String(value).trim();
}

function sslConfig(connectionString) {
  if (/sslmode=disable/i.test(connectionString)) return false;
  return { rejectUnauthorized: false };
}

async function connect(connectionString) {
  const client = new Client({
    connectionString,
    ssl: sslConfig(connectionString)
  });
  await client.connect();
  return client;
}

async function ensureTargetSchema(target) {
  await target.query(`
    CREATE TABLE IF NOT EXISTS public.asset_catalog_entries (
      id text PRIMARY KEY,
      entry jsonb NOT NULL,
      updated_at timestamptz NOT NULL DEFAULT now()
    );
  `);

  await target.query(`
    CREATE TABLE IF NOT EXISTS public.asset_marketplace_audit (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      at timestamptz NOT NULL DEFAULT now(),
      event text NOT NULL,
      wallet_address text NOT NULL,
      draft_id text,
      actor text,
      decision text,
      status_before text,
      status_after text,
      notes text,
      payload jsonb
    );
  `);

  await target.query(`
    CREATE TABLE IF NOT EXISTS public.asset_marketplace_drafts (
      wallet_address text NOT NULL,
      draft_id text NOT NULL,
      status text NOT NULL,
      moderation jsonb,
      normalized jsonb NOT NULL,
      created_at timestamptz NOT NULL DEFAULT now(),
      updated_at timestamptz NOT NULL DEFAULT now(),
      published_at timestamptz,
      PRIMARY KEY (wallet_address, draft_id)
    );
  `);

  await target.query(`CREATE SCHEMA IF NOT EXISTS telemetry;`);
  await target.query(`
    CREATE TABLE IF NOT EXISTS telemetry.marketplace_telemetry_events (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      occurred_at timestamptz NOT NULL DEFAULT now(),
      event_type text NOT NULL,
      source text,
      route text,
      http_method text,
      rpc_method text,
      tool_name text,
      action text,
      success boolean,
      status_code int,
      error_code text,
      error_message text,
      asset_id text,
      asset_type text,
      wallet_hash text,
      wallet_preview text,
      metadata jsonb NOT NULL DEFAULT '{}'::jsonb
    );
  `);
}

async function copyTable({
  source,
  target,
  sourceTable,
  targetTable,
  columns,
  conflictColumns = [],
  mergeColumns = []
}) {
  const selectSql = `SELECT ${columns.join(', ')} FROM ${sourceTable}`;
  const rows = (await source.query(selectSql)).rows;
  if (!rows.length) {
    console.log(`[copy] ${sourceTable} -> ${targetTable}: 0 rows`);
    return 0;
  }

  const valuesSql = rows
    .map((_, rowIdx) => `(${columns.map((__, colIdx) => `$${rowIdx * columns.length + colIdx + 1}`).join(', ')})`)
    .join(', ');
  const flatParams = rows.flatMap((row) => columns.map((col) => row[col]));

  let insertSql = `INSERT INTO ${targetTable} (${columns.join(', ')}) VALUES ${valuesSql}`;
  if (conflictColumns.length) {
    if (mergeColumns.length) {
      const setClause = mergeColumns.map((c) => `${c}=EXCLUDED.${c}`).join(', ');
      insertSql += ` ON CONFLICT (${conflictColumns.join(', ')}) DO UPDATE SET ${setClause}`;
    } else {
      insertSql += ` ON CONFLICT (${conflictColumns.join(', ')}) DO NOTHING`;
    }
  }

  await target.query(insertSql, flatParams);
  console.log(`[copy] ${sourceTable} -> ${targetTable}: ${rows.length} rows`);
  return rows.length;
}

async function tableExists(client, table) {
  const [schema, name] = String(table).split('.');
  if (!schema || !name) return false;
  const q = await client.query(
    `
      SELECT 1
      FROM information_schema.tables
      WHERE table_schema = $1
        AND table_name = $2
      LIMIT 1
    `,
    [schema, name]
  );
  return q.rowCount > 0;
}

async function resolveSourceTable(client, preferred, legacy) {
  if (await tableExists(client, preferred)) return preferred;
  if (legacy && (await tableExists(client, legacy))) return legacy;
  throw new Error(`Source table not found: expected ${preferred}${legacy ? ` or ${legacy}` : ''}`);
}

async function syncIdentitySequence(client, table, column) {
  const seqQuery = await client.query(
    `SELECT pg_get_serial_sequence($1, $2) AS seq`,
    [table, column]
  );
  const seq = seqQuery.rows?.[0]?.seq;
  if (!seq) return;
  await client.query(
    `SELECT setval($1, COALESCE((SELECT MAX(${column}) FROM ${table}), 1), true)`,
    [seq]
  );
}

async function main() {
  const sourceUrl = requireEnv('SOURCE_DATABASE_URL');
  const targetUrl = requireEnv('TARGET_DATABASE_URL');
  const includeTelemetry = String(process.env.INCLUDE_TELEMETRY || 'true').toLowerCase() !== 'false';

  const source = await connect(sourceUrl);
  const target = await connect(targetUrl);

  try {
    await ensureTargetSchema(target);
    await target.query('BEGIN');

    const sourceCatalogTable = await resolveSourceTable(
      source,
      'public.asset_catalog_entries',
      'public.soul_catalog_entries'
    );
    const sourceAuditTable = await resolveSourceTable(
      source,
      'public.asset_marketplace_audit',
      'public.soul_marketplace_audit'
    );
    const sourceDraftsTable = await resolveSourceTable(
      source,
      'public.asset_marketplace_drafts',
      'public.soul_marketplace_drafts'
    );

    await copyTable({
      source,
      target,
      sourceTable: sourceCatalogTable,
      targetTable: 'public.asset_catalog_entries',
      columns: ['id', 'entry', 'updated_at'],
      conflictColumns: ['id'],
      mergeColumns: ['entry', 'updated_at']
    });

    await copyTable({
      source,
      target,
      sourceTable: sourceAuditTable,
      targetTable: 'public.asset_marketplace_audit',
      columns: [
        'id',
        'at',
        'event',
        'wallet_address',
        'draft_id',
        'actor',
        'decision',
        'status_before',
        'status_after',
        'notes',
        'payload'
      ],
      conflictColumns: ['id']
    });

    await copyTable({
      source,
      target,
      sourceTable: sourceDraftsTable,
      targetTable: 'public.asset_marketplace_drafts',
      columns: [
        'wallet_address',
        'draft_id',
        'status',
        'moderation',
        'normalized',
        'created_at',
        'updated_at',
        'published_at'
      ],
      conflictColumns: ['wallet_address', 'draft_id'],
      mergeColumns: ['status', 'moderation', 'normalized', 'updated_at', 'published_at']
    });

    if (includeTelemetry) {
      await copyTable({
        source,
        target,
        sourceTable: 'telemetry.marketplace_telemetry_events',
        targetTable: 'telemetry.marketplace_telemetry_events',
        columns: [
          'id',
          'occurred_at',
          'event_type',
          'source',
          'route',
          'http_method',
          'rpc_method',
          'tool_name',
          'action',
          'success',
          'status_code',
          'error_code',
          'error_message',
          'asset_id',
          'asset_type',
          'wallet_hash',
          'wallet_preview',
          'metadata'
        ],
        conflictColumns: ['id']
      });
    } else {
      console.log('[copy] telemetry.marketplace_telemetry_events skipped');
    }

    await syncIdentitySequence(target, 'public.asset_marketplace_audit', 'id');
    await syncIdentitySequence(target, 'telemetry.marketplace_telemetry_events', 'id');
    await target.query('COMMIT');
    console.log('[done] Neon cutover copy completed');
  } catch (error) {
    await target.query('ROLLBACK').catch(() => {});
    throw error;
  } finally {
    await source.end().catch(() => {});
    await target.end().catch(() => {});
  }
}

main().catch((error) => {
  console.error('[error]', error?.message || error);
  process.exit(1);
});
