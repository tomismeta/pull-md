# x402 Payment Implementation QA Report

**Date:** 2026-02-11  
**Reviewer:** Critical QA Agent  
**Status:** ✅ **RESOLVED** - Payment flow working in production

---

## Resolution Summary

All critical issues have been fixed and the x402 payment flow is now **fully operational**. The first soul was successfully sold on 2026-02-11 via the production deployment.

### Test Results: ✅ PASSED
- **Client Signing:** EIP-712 typed data signatures working correctly
- **Server Verification:** On-chain signature validation successful
- **End-to-End:** Complete purchase flow completed
- **Delivery:** Soul content delivered immediately after payment verification

### What Was Fixed
1. ✅ Replaced `signMessage()` with `_signTypedData()` for EIP-712 compliance
2. ✅ Implemented proper EIP-3009 authorization struct
3. ✅ Added bytes32 nonce generation
4. ✅ Added on-chain signature verification (no facilitator needed)
5. ✅ Added authorization state checking for replay protection

---

## Original Report (Archived)

*The following section documents the issues that were identified and subsequently resolved:*

---

## Executive Summary

The SoulStarter x402 payment implementation has **fundamental architectural flaws** that will cause all payment attempts to fail. The implementation incorrectly treats x402 as a simple message-signing protocol, when it actually requires **EIP-3009 authorization-based transfers** with proper EIP-712 structured signatures.

### Severity: CRITICAL
- **Impact:** 100% payment failure rate
- **Risk:** Lost revenue, failed customer transactions, damaged reputation
- **Fix Required:** Complete rewrite of client-side payment signing logic

---

## What's Broken

### 1. **WRONG SIGNATURE SCHEME** (Critical)

**Current Implementation:**
```javascript
// Client-side (app.js) - WRONG
async function createPaymentPayload(requirements) {
  const message = JSON.stringify(requirements.payload);
  const signature = await signer.signMessage(message);  // ❌ WRONG!
  
  return {
    scheme: requirements.scheme,
    network: requirements.network,
    payload: requirements.payload,
    signature,
    from: walletAddress
  };
}
```

**What's Actually Required:**

The x402 "exact" scheme on EVM uses **EIP-3009** (`transferWithAuthorization`), which requires:

1. **EIP-712 structured signatures** (not simple `signMessage`)
2. **USDC contract's specific domain separator**
3. **Proper type hashing** for the authorization struct

The correct payload structure:
```javascript
{
  "x402Version": 1,
  "scheme": "exact",
  "network": "eip155:8453",
  "payload": {
    "signature": "0x...",  // EIP-712 signature (r, s, v)
    "authorization": {
      "from": "0xa7d395...",
      "to": "0x7F46aCB...",
      "value": "500000",  // 0.50 USDC
      "validAfter": "1740777600",
      "validBefore": "1740777900",
      "nonce": "0x..."  // bytes32, not string
    }
  }
}
```

**Why the Facilitator Rejects It:**

The Coinbase Facilitator expects to receive an EIP-3009 authorization that it can directly submit to the USDC contract's `transferWithAuthorization()` function. The current implementation sends a JSON string signature that the contract cannot verify.

---

### 2. **INCORRECT NONCE FORMAT** (Critical)

**Current Implementation:**
```javascript
// Server-side (download.js)
const nonce = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
// Example: "1739246200123-a1b2c3d4e5f6"
```

**What's Required:**

EIP-3009 requires `bytes32` nonce. The nonce must be:
- Exactly 32 bytes
- Random/unique for each authorization
- Passed through as bytes32 to the USDC contract

**Correct Implementation:**
```javascript
const nonce = ethers.utils.hexlify(ethers.utils.randomBytes(32));
// Example: "0x8f4e2c1d9a7b5e3f6c8d0a2b4e6f8c0d2a4b6e8f0c2d4e6f8a0b2c4d6e8f0a2b4"
```

---

### 3. **MISSING EIP-712 DOMAIN AND TYPES** (Critical)

**Current Implementation:** The code doesn't construct EIP-712 typed data at all.

**What's Required:**

USDC on Base uses this EIP-712 structure:

```javascript
const domain = {
  name: "USDC",
  version: "2",
  chainId: 8453,
  verifyingContract: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
};

const types = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};

const message = {
  from: buyerAddress,
  to: sellerAddress,
  value: "500000",  // 0.50 USDC (6 decimals)
  validAfter: Math.floor(Date.now() / 1000) - 60,  // 1 min ago
  validBefore: Math.floor(Date.now() / 1000) + 300,  // 5 min from now
  nonce: ethers.utils.hexlify(ethers.utils.randomBytes(32))
};
```

---

### 4. **INCORRECT SERVER RESPONSE FORMAT** (High)

**Current Implementation:**
```javascript
const paymentRequired = {
  scheme: 'exact',
  network: CONFIG.network,
  payload: {
    token: CONFIG.usdcAddress,
    to: CONFIG.sellerAddress,
    amount: CONFIG.price,
    timestamp: Date.now(),  // ❌ Not part of x402 spec
    nonce: nonce
  }
};
```

**What's Required:**

The x402 spec expects `validAfter` and `validBefore` timestamps, not a single `timestamp`:

```javascript
const paymentRequired = {
  scheme: 'exact',
  network: 'eip155:8453',
  payload: {
    token: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    to: sellerAddress,
    amount: '500000',
    validAfter: String(Math.floor(Date.now() / 1000) - 60),
    validBefore: String(Math.floor(Date.now() / 1000) + 300),
    nonce: ethers.utils.hexlify(ethers.utils.randomBytes(32))
  }
};
```

---

### 5. **MISSING `from` FIELD IN SERVER RESPONSE** (High)

The server doesn't include the `from` field in the 402 response, but the client needs to know the buyer's address to construct the authorization. This should be populated client-side after wallet connection.

---

### 6. **SIGNATURE FORMAT ISSUE** (Critical)

**Current:** Returns a single signature string from `signMessage()`

**Required:** Returns `{ r, s, v }` components from EIP-712 signing, or the compact signature format.

---

## How to Fix It

### Complete Rewrite Required for `app.js`

Replace the `createPaymentPayload` function with:

```javascript
async function createPaymentPayload(requirements) {
  const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
  const CHAIN_ID = 8453;
  
  // EIP-712 Domain for USDC on Base
  const domain = {
    name: "USDC",
    version: "2",
    chainId: CHAIN_ID,
    verifyingContract: USDC_ADDRESS
  };
  
  // EIP-712 Types for TransferWithAuthorization
  const types = {
    TransferWithAuthorization: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" }
    ]
  };
  
  // Current time in seconds
  const now = Math.floor(Date.now() / 1000);
  
  // Generate random bytes32 nonce
  const nonce = ethers.utils.hexlify(ethers.utils.randomBytes(32));
  
  // Construct the message
  const message = {
    from: walletAddress,
    to: requirements.payload.to,
    value: requirements.payload.amount,
    validAfter: String(now - 60),  // Valid 1 minute ago (allow clock drift)
    validBefore: String(now + 300), // Valid for 5 minutes
    nonce: nonce
  };
  
  // Sign the EIP-712 typed data
  const signature = await signer._signTypedData(domain, types, message);
  
  // Return x402 format payload
  return {
    x402Version: 1,
    scheme: "exact",
    network: requirements.network,
    payload: {
      signature: signature,
      authorization: {
        from: message.from,
        to: message.to,
        value: message.value,
        validAfter: message.validAfter,
        validBefore: message.validBefore,
        nonce: message.nonce
      }
    }
  };
}
```

### Fix for `download.js`

```javascript
// Update the 402 response
if (!paymentSignature) {
  const now = Math.floor(Date.now() / 1000);
  const nonce = ethers.utils.hexlify(ethers.utils.randomBytes(32));
  
  const paymentRequired = {
    scheme: 'exact',
    network: CONFIG.network,
    payload: {
      token: CONFIG.usdcAddress,
      to: CONFIG.sellerAddress,
      amount: CONFIG.price,
      validAfter: String(now - 60),
      validBefore: String(now + 300),
      nonce: nonce
    }
  };
  
  res.setHeader('PAYMENT-REQUIRED', Buffer.from(JSON.stringify(paymentRequired)).toString('base64'));
  return res.status(402).json({
    error: 'Payment required',
    message: 'This soul requires payment. Please provide a payment signature.',
    price: '$0.50',
    currency: 'USDC',
    network: 'Base'
  });
}

// Update verification to extract authorization properly
try {
  let paymentPayload;
  try {
    paymentPayload = JSON.parse(Buffer.from(paymentSignature, 'base64').toString());
  } catch (e) {
    return res.status(400).json({ error: 'Invalid payment signature encoding' });
  }
  
  // Validate x402 format
  if (!paymentPayload.x402Version || paymentPayload.x402Version !== 1) {
    return res.status(400).json({ error: 'Invalid x402 version' });
  }
  
  if (!paymentPayload.payload?.signature || !paymentPayload.payload?.authorization) {
    return res.status(400).json({ error: 'Invalid payment payload structure' });
  }
  
  const auth = paymentPayload.payload.authorization;
  
  // Replay protection using nonce from authorization
  if (usedNonces.has(auth.nonce)) {
    return res.status(400).json({ error: 'Payment already used' });
  }
  
  // Validate timestamps
  const now = Math.floor(Date.now() / 1000);
  if (now < parseInt(auth.validAfter) || now > parseInt(auth.validBefore)) {
    return res.status(400).json({ error: 'Payment outside valid time window' });
  }
  
  // Verify with Coinbase Facilitator
  const verifyResponse = await fetch(`${FACILITATOR_URL}/verify`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      x402Version: 1,
      scheme: 'exact',
      network: CONFIG.network,
      payload: paymentPayload.payload
    })
  });
  
  // ... rest of settlement logic
}
```

---

## Test Plan for Verification

### Test Scenario
- **Buyer:** `0xa7d395faf5e0a77a8d42d68ea01d2336671e5f55`
- **Seller:** `0x7F46aCB709cd8DF5879F84915CA431fB740989E4`
- **Amount:** 0.50 USDC (500000 micro-USDC)
- **Network:** Base (eip155:8453)

### Pre-Test Setup

1. **Ensure buyer wallet has:**
   - Minimum 0.50 USDC on Base
   - Small amount of ETH for gas (though facilitator pays gas, wallet may need some for signing)

2. **Verify USDC contract on Base:**
   - Address: `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`
   - Supports EIP-3009 (confirmed: yes, native USDC on Base)

### Test Cases

#### Test 1: Initial 402 Response
**Steps:**
1. Send GET request to `/api/souls/meta-starter-v1/download`
2. Do NOT include PAYMENT-SIGNATURE header

**Expected Result:**
- Status: 402
- Header: `PAYMENT-REQUIRED` present and base64-encoded
- Decoded payload contains:
  ```json
  {
    "scheme": "exact",
    "network": "eip155:8453",
    "payload": {
      "token": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "to": "0x7F46aCB709cd8DF5879F84915CA431fB740989E4",
      "amount": "500000",
      "validAfter": "<timestamp-60>",
      "validBefore": "<timestamp+300>",
      "nonce": "0x<64-hex-chars>"
    }
  }
  ```

**Pass Criteria:** All fields present, nonce is valid bytes32

---

#### Test 2: Payment Payload Construction
**Steps:**
1. Connect wallet (MetaMask or similar)
2. Click "Buy Soul"
3. Capture the signed payload before sending

**Expected Result:**
- Payload structure matches x402 spec
- Signature is 65 bytes (130 hex chars + 0x prefix)
- Authorization fields match requirements

**Verification:**
```javascript
// Decode and verify structure
const decoded = JSON.parse(atob(paymentSignatureBase64));
assert(decoded.x402Version === 1);
assert(decoded.scheme === "exact");
assert(decoded.network === "eip155:8453");
assert(decoded.payload.signature.startsWith("0x"));
assert(decoded.payload.signature.length === 132); // 0x + 130 hex chars
assert(decoded.payload.authorization.nonce.startsWith("0x"));
assert(decoded.payload.authorization.nonce.length === 66); // 0x + 64 hex chars
assert(decoded.payload.authorization.from === buyerAddress);
assert(decoded.payload.authorization.to === sellerAddress);
assert(decoded.payload.authorization.value === "500000");
```

---

#### Test 3: EIP-712 Signature Verification (Local)
**Steps:**
1. Extract signature and authorization from payment payload
2. Reconstruct EIP-712 domain and types
3. Call `ethers.utils.verifyTypedData()`

**Expected Result:**
- Recovered signer address matches `authorization.from`

**Verification Code:**
```javascript
const domain = {
  name: "USDC",
  version: "2",
  chainId: 8453,
  verifyingContract: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
};

const types = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};

const recovered = ethers.utils.verifyTypedData(
  domain,
  types,
  authorization,
  signature
);

assert(recovered.toLowerCase() === authorization.from.toLowerCase());
```

---

#### Test 4: Facilitator Verification API
**Steps:**
1. Submit payment payload to facilitator `/verify` endpoint
2. Check response

**Expected Result:**
```json
{
  "valid": true
}
```

**API Call:**
```bash
curl -X POST https://api.cdp.coinbase.com/x402/facilitator/v1/verify \
  -H "Content-Type: application/json" \
  -d '{
    "x402Version": 1,
    "scheme": "exact",
    "network": "eip155:8453",
    "payload": {
      "signature": "0x...",
      "authorization": {
        "from": "0xa7d395faf5e0a77a8d42d68ea01d2336671e5f55",
        "to": "0x7F46aCB709cd8DF5879F84915CA431fB740989E4",
        "value": "500000",
        "validAfter": "...",
        "validBefore": "...",
        "nonce": "0x..."
      }
    }
  }'
```

---

#### Test 5: End-to-End Payment Flow
**Steps:**
1. Clear any used nonces (fresh server instance)
2. Connect wallet with USDC
3. Click "Buy Soul"
4. Approve signature in wallet
5. Wait for response

**Expected Result:**
- Status: 200
- Content-Type: text/markdown
- Body: Soul content
- Header: `PAYMENT-RESPONSE` with settlement details

**Failure Modes to Check:**
- 402 with "Invalid payment" → Signature format wrong
- 400 with "Payment expired" → validBefore passed
- 400 with "Payment already used" → Nonce reuse
- 500 → Server error or facilitator down

---

#### Test 6: On-Chain Verification
**Steps:**
1. Complete a successful payment
2. Extract transaction hash from `PAYMENT-RESPONSE`
3. Check on BaseScan

**Expected Result:**
- Transaction shows `transferWithAuthorization` call
- From: Facilitator contract
- To: USDC contract
- Events: `Transfer` and `AuthorizationUsed`
- Value: 500000 (0.50 USDC)

**Verification URL:** `https://basescan.org/tx/{txHash}`

---

#### Test 7: Replay Protection
**Steps:**
1. Complete a successful payment
2. Try to reuse the same PAYMENT-SIGNATURE header

**Expected Result:**
- Status: 400
- Error: "Payment already used"

---

#### Test 8: Time Window Validation
**Steps:**
1. Construct payment with `validBefore` in the past
2. Submit to server

**Expected Result:**
- Status: 400
- Error: "Payment outside valid time window"

---

## Pass/Fail Criteria

### Critical (Must Pass)

| Test | Criteria | Status |
|------|----------|--------|
| 402 Response | Returns valid x402 payment requirements | PENDING |
| EIP-712 Signing | Client signs using `_signTypedData`, not `signMessage` | PENDING |
| Facilitator Verify | `/verify` returns `{ "valid": true }` | PENDING |
| Facilitator Settle | `/settle` returns `{ "settled": true }` | PENDING |
| On-Chain Transfer | USDC actually transfers from buyer to seller | PENDING |
| Replay Protection | Same nonce cannot be used twice | PENDING |

### High Priority (Must Pass)

| Test | Criteria | Status |
|------|----------|--------|
| Time Validation | validAfter/validBefore enforced | PENDING |
| Signature Recovery | EIP-712 signature recovers to correct signer | PENDING |
| Nonce Format | 32-byte hex format (0x + 64 chars) | PENDING |
| Content Delivery | Soul file delivered after settlement | PENDING |

### Medium Priority (Should Pass)

| Test | Criteria | Status |
|------|----------|--------|
| Error Messages | Clear, actionable error messages | PENDING |
| Wallet Compatibility | Works with MetaMask, Coinbase, WalletConnect | PENDING |
| Timeout Handling | Graceful handling of slow facilitator | PENDING |

---

## Dependencies to Add

The fixed implementation requires ethers.js v5 or v6:

```html
<!-- Already included in soul.html -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
```

No additional dependencies required for the client.

---

## Security Considerations

1. **Nonce Generation:** Must use cryptographically secure random (ethers.utils.randomBytes)
2. **Time Windows:** validAfter should be slightly in the past to allow clock drift
3. **Replay Protection:** Server MUST track used nonces
4. **SSL/TLS:** All API calls must use HTTPS in production
5. **Amount Validation:** Server should verify the authorization value matches expected price

---

## Estimated Fix Time

- **Understanding EIP-3009:** 2 hours
- **Code changes:** 4 hours
- **Testing:** 4 hours
- **Deployment:** 1 hour
- **Total:** ~11 hours

---

## References

1. [x402 Specification](https://github.com/coinbase/x402/blob/main/specs/x402-specification.md)
2. [EIP-3009: Transfer With Authorization](https://github.com/ethereum/EIPs/issues/3010)
3. [EIP-712: Typed Structured Data Signing](https://eips.ethereum.org/EIPS/eip-712)
4. [Coinbase x402 Docs](https://docs.cdp.coinbase.com/x402/welcome)
5. [USDC Contract on Base](https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913)

---

## Conclusion

**The current implementation is fundamentally broken** and will not work with the Coinbase Facilitator. The fix requires implementing proper EIP-3009 authorization signing with EIP-712 typed data signatures.

**DO NOT DEPLOY TO PRODUCTION** without fixing these issues. The current code will result in 100% payment failure and frustrated users.

**Recommended Action:**
1. Halt any production deployment plans
2. Implement the fixes outlined above
3. Run through all test cases
4. Verify on testnet (Base Sepolia) first
5. Deploy to production with monitoring

---

*Report generated by Critical QA Agent*  
*For questions, contact the development team*
